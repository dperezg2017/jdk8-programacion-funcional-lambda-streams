1: Utilitario:

    test: 
     public static void main (String[] args) {
       List<String> nombres = Arrays.asList("cortocortocorto", "medianomediano", "largo");
       List<Integer> numeros = Arrays.asList(5,7,1,6,3,4,2);
       
       Comparator<String> comparadorLongitud = (o1, o2) -> o1.length() - o2.length();
       Comparator<Integer> ordenaNumero = (o1,o2) -> o1.compareTo(o2);
       
       Collections.sort(nombres,comparadorLongitud);
       Collections.sort(numeros,ordenaNumero);
       Collections.reverse(numeros);
       
       System.out.println(nombres);
       System.out.println(numeros);
     }
    resultado:
      [largo, medianomediano, cortocortocorto]
      [7, 6, 5, 4, 3, 2, 1]

2: Funcional Interface: se agrega la anotacion para definirlo, solo se aceptan un metodo abstract
  Aprender mas de 40 interfaces funcionales que trae jdk 8 
  - BiConsumer,BiFunction,BinaryOperator, Interface UnaryOperator<T>(interfaces para el caso específico de T primitivo
    int, long, double)...

  #Anotacion para aceptar solo interfaes funcionales y solo 1 abstract
	 @FunctionalInterface
	 public interface FunctionalService {
  
	     int suma(int a, int b);
  
	     default int suma (int a, int b, int c){
	         return suma(a,suma(a,b));
	     }
	     static int suma3(int a, int b, int c){
	         return 1;
	     }
	 }
   # Composiciones con Function
   Function<Persona, String> nombre = per -> per.getNombre(); 
   nombre = nombre.andThen(it -> it.toUpperCase());

   #compose : añadir funcionalidad anterior
   Function<Coche, Persona> propietario = it -> it.getPropietario(); 
   Function<Persona, String> nombre = per -> per.getNombre();
   Function<Coche, String> nombrePropietario = nombre.compose(propietario);

   #acepta parametro pero no produce resultado, sirve para imprimir por consola
   Consumer<String> impresor = (it) -> {System.out.println(it);}

   #sin ningun parametro, que produce valor 
   Random random = new Random();
   Supplier<Integer> generador = () -> random.nextInt();

   #resultado de evaluar un objeto es cierto o falso(IntPredicate LongPredicate DoublePredicate)
   Predicate<String> cadenaCorta = it -> it.length() < 10;